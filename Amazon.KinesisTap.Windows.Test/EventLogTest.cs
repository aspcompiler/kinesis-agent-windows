/*
 * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
using System;
using System.Collections.Generic;
using System.Diagnostics.Eventing.Reader;
using System.Reactive;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml.Linq;

using Microsoft.Extensions.Configuration;
using Xunit;

using Amazon.KinesisTap.Core;
using Amazon.KinesisTap.Core.Test;

namespace Amazon.KinesisTap.Windows.Test
{
    public class EventLogTest
    {
        [Fact]
        public void TestInitialPositionEOS()
        {
            ListEventSink records = new ListEventSink();

            GenerateAndCaptureEvents(records, null);

            Assert.True(records.Count > 0);
        }

        [Fact]
        public void TestInitialPositionBOS()
        {
            string logName = "Application";
            string logSource = "Test";
            ListEventSink records = new ListEventSink();
            DateTime nowUtc = DateTime.UtcNow;
            string sourceId = "TestInitialPositionTimeStamp";
            DeleteExistingBookmarkFile(sourceId);

            using (EventLogSource source = new EventLogSource(logName, null, new PluginContext(null, null, null)))
            {
                source.Subscribe(records);
                source.Id = sourceId;
                source.InitialPosition = InitialPositionEnum.BOS;
                source.Start();

                do
                {
                    EventLog.WriteEntry(logSource, "A fresh message", EventLogEntryType.Information, 0);
                    System.Threading.Thread.Sleep(1000);
                }
                while (source.LastEventLatency > new TimeSpan(0, 0, 1));
                System.Threading.Thread.Sleep(1000);

                source.Stop();
                Assert.True(records.Count > 0);
                Assert.True(records[0].Timestamp < nowUtc);

                //Write some new logs after the source stop
                DateTime dateTime2Utc = DateTime.UtcNow;
                string msg = $"Message generated by EventLogTest {dateTime2Utc}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(logSource, msg, EventLogEntryType.Information, eventId);
                System.Threading.Thread.Sleep(1000);

                records.Clear();
                source.Start();
                System.Threading.Thread.Sleep(1000);
                //Should get the record when the source is stopped
                Assert.True(records.Count > 0);
                Assert.True(records[0].Timestamp >= dateTime2Utc);
            }
        }

        [Fact]
        public void TestInitialPositionTimeStamp()
        {
            string logName = "Application";
            string logSource = "Test";
            ListEventSink records = new ListEventSink();
            DateTime initialTimestamp = DateTime.Now.AddDays(-1);
            DateTime nowUtc = DateTime.UtcNow;
            string sourceId = "TestInitialPositionTimeStamp";
            DeleteExistingBookmarkFile(sourceId);

            using (EventLogSource source = new EventLogSource(logName, null, new PluginContext(null, null, null)))
            {
                source.Subscribe(records);
                source.Id = sourceId;
                source.InitialPosition = InitialPositionEnum.Timestamp;
                source.InitialPositionTimestamp = initialTimestamp;
                source.Start();

                do
                {
                    EventLog.WriteEntry(logSource, "A fresh message", EventLogEntryType.Information, 0);
                    System.Threading.Thread.Sleep(1000);
                }
                while (source.LastEventLatency > new TimeSpan(0, 0, 1));

                source.Stop();
                Assert.True(records.Count > 0, "There is an event after the timestamp.");
                Assert.True(records[0].Timestamp >= initialTimestamp.ToUniversalTime() && records[0].Timestamp < nowUtc, "There is an earlier event after the initial timestamp.");
                DateTime dateTime1 = records[records.Count - 1].Timestamp;

                //Write some new logs after the source stop
                DateTime dateTime2 = DateTime.Now;
                string msg = $"Message generated by EventLogTest {dateTime2}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(logSource, msg, EventLogEntryType.Information, eventId);
                System.Threading.Thread.Sleep(1000);

                records.Clear();
                source.Start();
                System.Threading.Thread.Sleep(2000);
                //Should get the record when the source is stopped
                Assert.True(records.Count > 0, "Should get the new record.");
                Assert.True(records[0].Timestamp >= dateTime1, "Should pick up new records.");
            }
        }

        [Fact]
        public void TestInitialPositionBookMark()
        {
            string logName = "Application";
            string logSource = "Test";
            ListEventSink records = new ListEventSink();
            string sourceId = "TestInitialPositionBookMark";
            DeleteExistingBookmarkFile(sourceId);

            //This should generate a water mark file
            using (EventLogSource source = new EventLogSource(logName, null, new PluginContext(null, null, null)))
            {
                source.Subscribe(records);
                source.Id = sourceId;
                source.InitialPosition = InitialPositionEnum.Bookmark;
                source.Start();

                var nowUtc = DateTime.UtcNow;
                string msg = $"Message generated by EventLogTest {nowUtc}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                if (!EventLog.SourceExists(logSource))
                {
                    EventLog.CreateEventSource(logSource, logName);
                }
                EventLog.WriteEntry(logSource, msg, EventLogEntryType.Information, eventId);

                System.Threading.Thread.Sleep(1000);
                source.Stop();

                //Write some new logs after the source stop
                DateTime dateTime2Utc = DateTime.UtcNow;
                msg = $"Message generated by EventLogTest {dateTime2Utc}";
                EventLog.WriteEntry(logSource, msg, EventLogEntryType.Information, eventId);
                System.Threading.Thread.Sleep(1000);


                records.Clear();
                source.Start();
                System.Threading.Thread.Sleep(1000);
                //Should get the record when the source is stopped
                var foundRecord = records.FirstOrDefault(r => msg.Equals(((EventRecordEnvelope)r).Data.Description));
                Assert.NotNull(foundRecord);
                Assert.True(foundRecord.Timestamp >= dateTime2Utc);
            }
        }

        [Fact]
        public void TestNoEventData()
        {
            ListEventSink records = new ListEventSink();
            var config = TestUtility.GetConfig("Sources", "ApplicationLog");

            GenerateAndCaptureEvents(records, config);

            Assert.Null(((EventRecordEnvelope)records[0]).Data.EventData);
        }

        [Fact]
        public void TestEventData()
        {
            ListEventSink records = new ListEventSink();
            var config = TestUtility.GetConfig("Sources", "ApplicationLogWithEventData");

            GenerateAndCaptureEvents(records, config);

            Assert.True(((EventRecordEnvelope)records[0]).Data.EventData.Count > 0);
        }


        [Fact]
        public void TestEventXml2()
        {
            ListEventSink records = new ListEventSink();
            var config = TestUtility.GetConfig("Sources", "ApplicationLogWithEventData");

            GenerateAndCaptureEvents(records, config);
            string xml = ((EventRecordEnvelope)records[0]).GetMessage("xml2");
            var xDocument = XDocument.Parse(xml);
            var xRoot = xDocument.Root;
            Assert.Equal("Event", xRoot.Name.LocalName);
            XNamespace ns = xRoot.GetDefaultNamespace();
            Assert.NotNull(xRoot.Element(ns + "System"));
            Assert.NotNull(xRoot.Element(ns + "EventData"));
        }

        [Fact]
        public void TestExcludeOwnSecurityEvents()
        {
            var filter = EventInfoFilters.GetFilter(EventInfoFilters.EXCLUDE_OWN_SECURITY_EVENTS);
            Assert.True(filter(new EventInfo()));
            Assert.False(filter(new EventInfo
            {
                LogName = "Security",
                EventData = new List<object>()
                {
                    Utility.MainModulePath
                }
            }));
            //Check the \device\harddiskvolumnX rooted path
            Assert.False(filter(new EventInfo
            {
                LogName = "Security",
                EventData = new List<object>()
                {
                    @"\device\harddiskvolume1" + Utility.MainModulePath.Substring(2)
                }
            }));
        }

        /// <summary>
        /// Test if the EventLogSource is required
        /// </summary>
        [Theory]
        [InlineData("NonExisting")]
        [InlineData("NonExistingNotRequired")]
        public void TestRequired(string sourceId)
        {
            var config = TestUtility.GetConfig("Sources", sourceId);
            string logName = config["LogName"];
            string requiredSetting = config["Required"];
            bool required = string.IsNullOrWhiteSpace(requiredSetting) ?
                true : bool.Parse(requiredSetting);
            MemoryLogger logger = new MemoryLogger(null);
            using (EventLogSource source = new EventLogSource(logName, null, new PluginContext(config, logger, null)))
            {
                source.Start();

                System.Threading.Thread.Sleep(1000);

                if (required)
                {
                    Assert.NotEmpty(logger.Entries.Where(e => e.Contains("error")));
                }
                else
                {
                    Assert.Empty(logger.Entries.Where(e => e.Contains("error")));
                }
            }
        }

        /// <summary>
        /// Make sure that 'SaveBookmarkInternal' handles out-dated bookmark position correctly.
        /// </summary>
        [Fact]
        public void TestSavingOutdatedBookmark()
        {
            string logName = "Application";
            string logSource = nameof(TestSavingOutdatedBookmark);
            DeleteExistingBookmarkFile(logSource);

            if (!EventLog.SourceExists(logSource))
            {
                EventLog.CreateEventSource(logSource, logName);
            }

            using (EventLogSource source = new EventLogSource(logName, null, new PluginContext(null, null, null)))
            {
                source.Id = logSource;
                source.InitialPosition = InitialPositionEnum.Bookmark;
                source.Start();
                System.Threading.Thread.Sleep(1000);
                EventLog.WriteEntry(logSource, "TestSavingOutdatedBookmark test message");
                System.Threading.Thread.Sleep(1000);
                var lastSavedBookmark = source.LastSavedBookmark;

                // execute a save bookmark operation at the '0' position
                source.SaveBookmarkInternal(0, false);

                // assert that 'SaveBookmarkInternal' does not throw exception,
                // and the saved bookmark remains the latest position.
                Assert.Equal(lastSavedBookmark, source.LastSavedBookmark);
            }
        }

        private static void DeleteExistingBookmarkFile(string sourceId)
        {
            string bookmarkFile = Path.Combine(Utility.GetKinesisTapProgramDataPath(), ConfigConstants.BOOKMARKS, $"{sourceId}.bm");
            if (File.Exists(bookmarkFile))
            {
                File.Delete(bookmarkFile);
            }
        }

        private static void GenerateAndCaptureEvents(ListEventSink records, IConfiguration config)
        {
            string logName = "Application";
            string logSource = "Test";
            using (EventLogSource source = new EventLogSource(logName, null, new PluginContext(config, null, null)))
            {
                source.Subscribe(records);
                source.Start();

                string msg = $"Message generated by EventLogTest {DateTime.Now}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                if (!EventLog.SourceExists(logSource))
                {
                    EventLog.CreateEventSource(logSource, logName);
                }
                EventLog.WriteEntry(logSource, msg, EventLogEntryType.Information, eventId);

                System.Threading.Thread.Sleep(1000);

                source.Stop();
            }
        }
    }
}
