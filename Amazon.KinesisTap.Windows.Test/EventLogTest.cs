/*
 * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using Microsoft.Extensions.Configuration;
using Xunit;
using Amazon.KinesisTap.Core;
using Amazon.KinesisTap.Core.Test;
using System.Diagnostics.Eventing.Reader;
using Newtonsoft.Json.Linq;

namespace Amazon.KinesisTap.Windows.Test
{
    public class EventLogTest : IDisposable
    {
        private const string LogName = "Application";
        private const string LogSource = nameof(EventLogTest);
        private readonly string PollingSourceQuery = $"*[System[Provider[@Name = '{LogSource}']]]";
        private readonly BookmarkManager _bookmarkManager = new BookmarkManager();

        public EventLogTest()
        {
            if (!EventLog.SourceExists(LogSource))
            {
                EventLog.CreateEventSource(LogSource, LogName);
            }
        }

        [Fact]
        public void TestInitialPositionEOS()
        {
            ListEventSink records = new ListEventSink();

            GenerateAndCaptureEvents(records, null);

            Assert.True(records.Count > 0);
        }

        [Fact]
        public void TestInitialPositionEOSPollingSource()
        {
            ListEventSink records = new ListEventSink();

            using (WindowsEventPollingSource source = new WindowsEventPollingSource(LogName, null, false, new PluginContext(null, null, null, _bookmarkManager)))
            {
                source.Subscribe(records);
                source.Start();

                string msg = $"Message generated by EventLogTest {DateTime.Now}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId);

                System.Threading.Thread.Sleep(1000);

                source.Stop();
            }

            Assert.True(records.Count > 0);
        }

        [Fact]
        public void TestInitialPositionBOS()
        {
            ListEventSink records = new ListEventSink();
            DateTime nowUtc = DateTime.UtcNow;
            string sourceId = "TestInitialPositionTimeStamp";
            DeleteExistingBookmarkFile(sourceId);

            using (EventLogSource source = new EventLogSource(LogName, null, new PluginContext(null, null, null, _bookmarkManager)))
            {
                source.Subscribe(records);
                source.Id = sourceId;
                source.InitialPosition = InitialPositionEnum.BOS;
                source.Start();

                do
                {
                    EventLog.WriteEntry(LogSource, "A fresh message", EventLogEntryType.Information, 0);
                    System.Threading.Thread.Sleep(1000);
                }
                while (source.LastEventLatency > new TimeSpan(0, 0, 1));
                System.Threading.Thread.Sleep(1000);

                source.Stop();
                Assert.True(records.Count > 0);
                Assert.True(records[0].Timestamp < nowUtc);

                //Write some new logs after the source stop
                DateTime dateTime2Utc = DateTime.UtcNow;
                string msg = $"Message generated by EventLogTest {dateTime2Utc}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId);
                System.Threading.Thread.Sleep(1000);

                records.Clear();
                source.Start();
                System.Threading.Thread.Sleep(1000);
                //Should get the record when the source is stopped
                Assert.True(records.Count > 0);
                Assert.True(records[0].Timestamp >= dateTime2Utc);
            }
        }

        [Fact]
        public void TestInitialPositionBOSPollingSource()
        {
            ListEventSink records = new ListEventSink();
            DateTime nowUtc = DateTime.UtcNow;
            string sourceId = "TestInitialPositionTimeStamp";
            DeleteExistingBookmarkFile(sourceId);

            using (WindowsEventPollingSource source = new WindowsEventPollingSource(LogName, PollingSourceQuery, false, new PluginContext(null, null, null, _bookmarkManager)))
            {
                source.Subscribe(records);
                source.Id = sourceId;
                source.InitialPosition = InitialPositionEnum.BOS;
                source.Start();

                do
                {
                    EventLog.WriteEntry(LogSource, "A fresh message", EventLogEntryType.Information, 0);
                    System.Threading.Thread.Sleep(1000);
                }
                while (source.LastEventLatency > new TimeSpan(0, 0, 1));
                System.Threading.Thread.Sleep(1000);

                source.Stop();
                Assert.True(records.Count > 0);
                Assert.True(records[0].Timestamp < nowUtc);

                //Write some new logs after the source stop
                DateTime dateTime2Utc = DateTime.UtcNow;
                string msg = $"Message generated by EventLogTest {dateTime2Utc}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId);
                System.Threading.Thread.Sleep(1000);

                records.Clear();
                source.Reset();
                source.Start();
                System.Threading.Thread.Sleep(5000); // We sleep for 5s here to ensure that 

                //Should get the record when the source is stopped
                Assert.True(records.Count > 0);
                var foundRecord = records.FirstOrDefault(r => eventId.Equals(((RawEventRecordEnvelope)r).Data.Id));
                Assert.True(foundRecord.Timestamp >= dateTime2Utc); // Assert that the record exists and was created after the source stop.
            }
        }

        [Fact]
        public void TestInitialPositionTimeStamp()
        {
            string logName = "Application";
            string logSource = "EventLogTest";
            ListEventSink records = new ListEventSink();
            DateTime initialTimestamp = DateTime.Now.AddDays(-1);
            DateTime nowUtc = DateTime.UtcNow;
            string sourceId = "TestInitialPositionTimeStamp";
            DeleteExistingBookmarkFile(sourceId);

            using (EventLogSource source = new EventLogSource(logName, null, new PluginContext(null, null, null, _bookmarkManager)))
            {
                source.Subscribe(records);
                source.Id = sourceId;
                source.InitialPosition = InitialPositionEnum.Timestamp;
                source.InitialPositionTimestamp = initialTimestamp;
                source.Start();

                do
                {
                    EventLog.WriteEntry(logSource, "A fresh message", EventLogEntryType.Information, 0);
                    System.Threading.Thread.Sleep(1000);
                }
                while (source.LastEventLatency > new TimeSpan(0, 0, 1));

                source.Stop();
                Assert.True(records.Count > 0, "There is an event after the timestamp.");
                Assert.True(records[0].Timestamp >= initialTimestamp.ToUniversalTime() && records[0].Timestamp < nowUtc, "There is an earlier event after the initial timestamp.");
                DateTime dateTime1 = records[records.Count - 1].Timestamp;

                //Write some new logs after the source stop
                DateTime dateTime2 = DateTime.Now;
                string msg = $"Message generated by EventLogTest {dateTime2}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(logSource, msg, EventLogEntryType.Information, eventId);
                System.Threading.Thread.Sleep(1000);

                records.Clear();
                source.Start();
                System.Threading.Thread.Sleep(2000);
                //Should get the record when the source is stopped
                Assert.True(records.Count > 0, "Should get the new record.");
                Assert.True(records[0].Timestamp >= dateTime1, "Should pick up new records.");
            }
        }

        [Fact]
        public void TestInitialPositionTimeStampPollingSource()
        {
            ListEventSink records = new ListEventSink();
            DateTime initialTimestamp = DateTime.Now.AddDays(-1);
            DateTime nowUtc = DateTime.UtcNow;
            string sourceId = "TestInitialPositionTimeStamp";
            DeleteExistingBookmarkFile(sourceId);

            using (WindowsEventPollingSource source = new WindowsEventPollingSource(LogName, PollingSourceQuery, false, new PluginContext(null, null, null, _bookmarkManager)))
            {
                source.Subscribe(records);
                source.Id = sourceId;
                source.InitialPosition = InitialPositionEnum.Timestamp;
                source.InitialPositionTimestamp = initialTimestamp;
                source.Start();

                do
                {
                    EventLog.WriteEntry(LogSource, "A fresh message", EventLogEntryType.Information, 0);
                    System.Threading.Thread.Sleep(1000);
                }
                while (source.LastEventLatency > new TimeSpan(0, 0, 1));

                source.Stop();
                Assert.True(records.Count > 0, "There is an event after the timestamp.");
                Assert.True(records[0].Timestamp >= initialTimestamp.ToUniversalTime() && records[0].Timestamp < nowUtc, "There is an earlier event after the initial timestamp.");
                DateTime dateTime1 = records[records.Count - 1].Timestamp;

                //Write some new logs after the source stop
                DateTime dateTime2 = DateTime.Now;
                string msg = $"Message generated by EventLogTest {dateTime2}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                records.Clear();
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId);
                System.Threading.Thread.Sleep(1000);

                source.Reset();
                source.Start();
                System.Threading.Thread.Sleep(5000);
                //Should get the record when the source is stopped
                Assert.True(records.Count > 0, "Should get the new record.");
                var foundRecord = records.FirstOrDefault(r => eventId.Equals(((RawEventRecordEnvelope)r).Data.Id));
                Assert.True(foundRecord.Timestamp >= dateTime1); // Assert that the record exists and was created after the source stop.
            }
        }


        [Fact]
        public void TestInitialPositionBookMark()
        {
            ListEventSink records = new ListEventSink();
            string sourceId = "TestInitialPositionBookMark";
            DeleteExistingBookmarkFile(sourceId);

            //This should generate a water mark file
            using (EventLogSource source = new EventLogSource(LogName, null, new PluginContext(null, null, null, _bookmarkManager)))
            {
                source.Subscribe(records);
                source.Id = sourceId;
                source.InitialPosition = InitialPositionEnum.Bookmark;
                source.Start();

                var nowUtc = DateTime.UtcNow;
                string msg = $"Message generated by EventLogTest {nowUtc}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId);

                System.Threading.Thread.Sleep(1000);
                source.Stop();

                //Write some new logs after the source stop
                DateTime dateTime2Utc = DateTime.UtcNow;
                msg = $"Message generated by EventLogTest {dateTime2Utc}";
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId);
                System.Threading.Thread.Sleep(1000);

                records.Clear();
                source.Start();
                System.Threading.Thread.Sleep(1000);
                //Should get the record when the source is stopped
                var foundRecord = records.FirstOrDefault(r => msg.Equals(((EventRecordEnvelope)r).Data.Description));
                Assert.NotNull(foundRecord);
                Assert.True(foundRecord.Timestamp >= dateTime2Utc);
            }
        }

        [Fact]
        public void TestInitialPositionBookMarkPollingSource()
        {
            ListEventSink records = new ListEventSink();
            string sourceId = "TestInitialPositionBookMark";
            DeleteExistingBookmarkFile(sourceId);

            //This should generate a water mark file
            using (WindowsEventPollingSource source = new WindowsEventPollingSource(LogName, PollingSourceQuery, false, new PluginContext(null, null, null, _bookmarkManager)))
            {
                source.Subscribe(records);
                source.Id = sourceId;
                source.InitialPosition = InitialPositionEnum.Bookmark;
                source.Start();

                var nowUtc = DateTime.UtcNow;
                string msg = $"Message generated by EventLogTest {nowUtc}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId);

                System.Threading.Thread.Sleep(1000);
                var foundRecord = records.FirstOrDefault(r => eventId.Equals(((RawEventRecordEnvelope)r).Data.Id));
                Assert.NotNull(foundRecord);
                Assert.True(foundRecord.Timestamp >= nowUtc); // Assert that the record exists and was created after the source stop.

                source.Stop();

                //Write some new logs after the source stop
                DateTime dateTime2Utc = DateTime.UtcNow;
                int eventId2 = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                msg = $"Message generated by EventLogTest {dateTime2Utc}";
                records.Clear();
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId2);
                System.Threading.Thread.Sleep(1000);

                records.Clear();

                source.Reset();
                source.Start();
                System.Threading.Thread.Sleep(5000);
                //Should get the record when the source is stopped
                var foundRecord2 = records.FirstOrDefault(r => eventId2.Equals(((RawEventRecordEnvelope)r).Data.Id));
                Assert.NotNull(foundRecord2);
                Assert.True(foundRecord2.Timestamp >= dateTime2Utc); // Assert that the record exists and was created after the source stop.
            }
        }

        [Fact]
        public void TestNoEventData()
        {
            ListEventSink records = new ListEventSink();
            var config = TestUtility.GetConfig("Sources", "ApplicationLog");

            GenerateAndCaptureEvents(records, config);

            Assert.Null(((EventRecordEnvelope)records[0]).Data.EventData);
        }

        [Fact]
        public void TestEventData()
        {
            ListEventSink records = new ListEventSink();
            var config = TestUtility.GetConfig("Sources", "ApplicationLogWithEventData");

            GenerateAndCaptureEvents(records, config);

            Assert.True(((EventRecordEnvelope)records[0]).Data.EventData.Count > 0);
        }

        [Fact]
        public void TestEventXml2()
        {
            ListEventSink records = new ListEventSink();
            var config = TestUtility.GetConfig("Sources", "ApplicationLogWithEventData");

            GenerateAndCaptureEvents(records, config);
            string xml = ((EventRecordEnvelope)records[0]).GetMessage("xml2");
            var xDocument = XDocument.Parse(xml);
            var xRoot = xDocument.Root;
            Assert.Equal("Event", xRoot.Name.LocalName);
            XNamespace ns = xRoot.GetDefaultNamespace();
            Assert.NotNull(xRoot.Element(ns + "System"));
            Assert.NotNull(xRoot.Element(ns + "EventData"));
        }

        [Fact]
        public void TestEventXml2PollingSource()
        {
            ListEventSink records = new ListEventSink();
            var config = TestUtility.GetConfig("Sources", "ApplicationLogWithEventData");

            using (WindowsEventPollingSource source = new WindowsEventPollingSource(LogName, PollingSourceQuery, false, new PluginContext(config, null, null, _bookmarkManager)))
            {
                source.Subscribe(records);
                source.Start();

                string msg = $"Message generated by EventLogTest {DateTime.Now}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId);

                System.Threading.Thread.Sleep(1000);

                source.Stop();
            }

            string xml = ((RawEventRecordEnvelope)records[0]).GetMessage("xml2");
            var xDocument = XDocument.Parse(xml);
            var xRoot = xDocument.Root;
            Assert.Equal("Event", xRoot.Name.LocalName);
            XNamespace ns = xRoot.GetDefaultNamespace();
            Assert.NotNull(xRoot.Element(ns + "System"));
            Assert.NotNull(xRoot.Element(ns + "EventData"));
        }

        //[Fact]
        //public void TestExcludeOwnSecurityEvents()
        //{
        //    var filter = EventInfoFilters.GetFilter(EventInfoFilters.EXCLUDE_OWN_SECURITY_EVENTS);
        //    Assert.True(filter(new EventInfo()));
        //    Assert.False(filter(new EventInfo
        //    {
        //        LogName = "Security",
        //        EventData = new List<object>()
        //        {
        //            Utility.MainModulePath
        //        }
        //    }));
        //    //Check the \device\harddiskvolumnX rooted path
        //    Assert.False(filter(new EventInfo
        //    {
        //        LogName = "Security",
        //        EventData = new List<object>()
        //        {
        //            @"\device\harddiskvolume1" + Utility.MainModulePath.Substring(2)
        //        }
        //    }));
        //}

        /// <summary>
        /// Test if the EventLogSource is required
        /// </summary>
        [Theory]
        [InlineData("NonExisting")]
        [InlineData("NonExistingNotRequired")]
        public void TestRequired(string sourceId)
        {
            var config = TestUtility.GetConfig("Sources", sourceId);
            string logName = config["LogName"];
            string requiredSetting = config["Required"];
            bool required = string.IsNullOrWhiteSpace(requiredSetting) ?
                true : bool.Parse(requiredSetting);
            MemoryLogger logger = new MemoryLogger(null);
            using (EventLogSource source = new EventLogSource(logName, null, new PluginContext(config, logger, null, _bookmarkManager)))
            {
                source.Start();

                System.Threading.Thread.Sleep(1000);

                if (required)
                {
                    Assert.NotEmpty(logger.Entries.Where(e => e.Contains("error")));
                }
                else
                {
                    Assert.Empty(logger.Entries.Where(e => e.Contains("error")));
                }
            }
        }

        /// <summary>
        /// Make sure that 'SaveBookmarkInternal' handles out-dated bookmark position correctly.
        /// </summary>
        [Fact]
        public void TestSavingOutdatedBookmark()
        {
            string logName = "Application";
            string logSource = nameof(TestSavingOutdatedBookmark);
            DeleteExistingBookmarkFile(logSource);

            if (!EventLog.SourceExists(logSource))
            {
                EventLog.CreateEventSource(logSource, logName);
            }

            using (EventLogSource source = new EventLogSource(logName, null, new PluginContext(null, null, null, _bookmarkManager)))
            {
                source.Id = logSource;
                source.InitialPosition = InitialPositionEnum.Bookmark;
                source.Start();
                System.Threading.Thread.Sleep(1000);
                EventLog.WriteEntry(logSource, "TestSavingOutdatedBookmark test message");
                System.Threading.Thread.Sleep(1000);
                var lastSavedBookmark = source.LastSavedBookmark;

                // execute a save bookmark operation at the '0' position
                source.SaveBookmarkInternal(0, false);

                // assert that 'SaveBookmarkInternal' does not throw exception,
                // and the saved bookmark remains the latest position.
                Assert.Equal(lastSavedBookmark, source.LastSavedBookmark);
            }
        }

        /// <summary>
        /// Make sure that 'SaveBookmarkInternal' handles out-dated bookmark position correctly.
        /// </summary>
        [Fact]
        public void TestSavingOutdatedBookmarkPollingSource()
        {
            string logName = "Application";
            string logSource = nameof(TestSavingOutdatedBookmark);
            string query = $"*[System[Provider[@Name = '{logSource}']]]";

            DeleteExistingBookmarkFile(logSource);

            if (!EventLog.SourceExists(logSource))
            {
                EventLog.CreateEventSource(logSource, logName);
            }

            using (WindowsEventPollingSource source = new WindowsEventPollingSource(logName, query, false, new PluginContext(null, null, null, _bookmarkManager)))
            {
                source.Id = logSource;
                source.InitialPosition = InitialPositionEnum.Bookmark;
                source.Start();
                System.Threading.Thread.Sleep(1000);
                EventLog.WriteEntry(logSource, "TestSavingOutdatedBookmark test message");
                System.Threading.Thread.Sleep(1000);
                var lastSavedBookmark = source._lastSavedBookmark;

                // execute a save bookmark operation at the '0' position
                source.SaveBookmarkInternal(0, false);

                // assert that 'SaveBookmarkInternal' does not throw exception,
                // and the saved bookmark remains the latest position.
                Assert.Equal(lastSavedBookmark, source._lastSavedBookmark);
            }
        }

        /// <summary>
        /// Verify that "RenderedXml" generates the <RenderedInfo /> section
        /// </summary>
        [Fact]
        public void TestRenderedXmlFormat()
        {
            using (var eventReader = new EventLogReader("Application", PathType.LogName))
            {
                EventLog.WriteEntry(LogSource, "Test message", EventLogEntryType.Information, 0);
                EventRecord eventRecord = null;
                do
                {
                    System.Threading.Thread.Sleep(100);
                    eventRecord = eventReader.ReadEvent();
                } while (eventRecord == null);

                var envelop = new EventRecordEnvelope(eventRecord, true, 0);
                var renderedXml = envelop.GetMessage("RenderedXml");
                var xml = XElement.Parse(renderedXml);
                var renderingInfo = xml.Element(xml.Name.Namespace + "RenderingInfo");
                Assert.NotNull(renderingInfo);
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Message"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Level"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Task"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Opcode"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Channel"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Provider"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Keywords"));
            }
        }

        /// <summary>
        /// Verify that "RenderedXml" generates the <RenderedInfo /> section
        /// </summary>
        [Fact]
        public void TestRenderedXmlFormatRawRecordEnvelope()
        {
            using (var eventReader = new EventLogReader("Application", PathType.LogName))
            {
                EventLog.WriteEntry(LogSource, "Test message", EventLogEntryType.Information, 0);
                EventRecord eventRecord = null;
                do
                {
                    System.Threading.Thread.Sleep(100);
                    eventRecord = eventReader.ReadEvent();
                } while (eventRecord == null);

                var envelop = new RawEventRecordEnvelope(eventRecord, true, 0);
                var renderedXml = envelop.GetMessage("RenderedXml");
                var xml = XElement.Parse(renderedXml);
                var renderingInfo = xml.Element(xml.Name.Namespace + "RenderingInfo");
                Assert.NotNull(renderingInfo);
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Message"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Level"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Task"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Opcode"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Channel"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Provider"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Keywords"));
            }
        }

        [Fact]
        public void TestRawEventRecordEnvelope_GivenJsonFormat_FallsBackToEventRecordEnvelopeBehavior()
        {
            using (var eventReader = new EventLogReader("Application", PathType.LogName))
            {
                EventLog.WriteEntry(LogSource, "Test message", EventLogEntryType.Information, 0);
                EventRecord eventRecord = null;
                do
                {
                    System.Threading.Thread.Sleep(100);
                    eventRecord = eventReader.ReadEvent();
                } while (eventRecord == null);

                var envelope = new RawEventRecordEnvelope(eventRecord, true, 0);
                var jsonStr = envelope.GetMessage("json");
                var jsonObj = JObject.Parse(jsonStr);
                Assert.NotNull(jsonObj);
                Assert.NotNull(jsonObj["EventId"]);
                Assert.NotNull(jsonObj["LevelDisplayName"]);
                Assert.NotNull(jsonObj["LogName"]);
                Assert.NotNull(jsonObj["MachineName"]);
                Assert.NotNull(jsonObj["ProviderName"]);
                Assert.NotNull(jsonObj["TimeCreated"]);
                Assert.NotNull(jsonObj["Description"]);
                Assert.NotNull(jsonObj["Index"]);
                Assert.NotNull(jsonObj["UserName"]);
                Assert.NotNull(jsonObj["Keywords"]);
            }
        }

        private static void DeleteExistingBookmarkFile(string sourceId)
        {
            string bookmarkFile = Path.Combine(Utility.GetKinesisTapProgramDataPath(), ConfigConstants.BOOKMARKS, $"{sourceId}.bm");
            if (File.Exists(bookmarkFile))
            {
                File.Delete(bookmarkFile);
            }
        }

        private void GenerateAndCaptureEvents(ListEventSink records, IConfiguration config)
        {
            using (EventLogSource source = new EventLogSource(LogName, null, new PluginContext(config, null, null, _bookmarkManager)))
            {
                source.Subscribe(records);
                source.Start();

                string msg = $"Message generated by EventLogTest {DateTime.Now}";
                int eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
                EventLog.WriteEntry(LogSource, msg, EventLogEntryType.Information, eventId);

                System.Threading.Thread.Sleep(1000);

                source.Stop();
            }
        }

        public void Dispose()
        {
            if (EventLog.SourceExists(LogSource))
            {
                EventLog.DeleteEventSource(LogSource);
            }
        }
    }
}
